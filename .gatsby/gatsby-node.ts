import { GatsbyNode, PluginOptions, SetFieldsOnGraphQLNodeTypeArgs } from 'gatsby';
import { GraphQLString } from 'graphql';
import * as path from 'path';
import createPostsPages from './pagination/create-post-pages';
import createDesignListPages from './pagination/create-design-list-pages';
export const setFieldsOnGraphQLNodeType: GatsbyNode['setFieldsOnGraphQLNodeType'] = async (
  args: SetFieldsOnGraphQLNodeTypeArgs,
  options: PluginOptions
) => {
  if (args.type.name === `MarkdownRemark`) {
    return {
      url: {
        type: GraphQLString,
        resolve: (source: any) => `https://glweems.com${source.frontmatter.path}`
      },
      disqusIdentifier: {
        type: GraphQLString,
        resolve: (source: any) => String(source.frontmatter.id)
      }
    };
  }

  // by default return empty object
  return {};
};

// Create Pages
export const createPages: GatsbyNode['createPages'] = async (gatsbyNode) => {
  const { actions, graphql, reporter } = gatsbyNode;
  const { createPage } = actions;

  const result = await graphql<Data>(`
    query CreatePagesQuery {
      posts: allMarkdownRemark(sort: { fields: frontmatter___date, order: DESC }) {
        nodes {
          frontmatter {
            path
          }
        }
      }

      designs: allDesignsYaml {
        nodes {
          slug
        }
      }
    }
  `);

  // Handle errors
  if (result.errors) {
    reporter.panicOnBuild(`Error while running GraphQL query.`);
    return;
  }

  // Create Blog Posts
  const blogPosts = result?.data?.posts.nodes;

  blogPosts?.forEach(({ frontmatter }, index) => {
    createPage({
      path: frontmatter.path,
      component: path.resolve(`src/templates/BlogPost/BlogPostTemplate.tsx`),
      context: {
        slug: frontmatter.path,
        prev: blogPosts[index - 1] && blogPosts[index - 1].frontmatter.path,
        next: blogPosts[index + 1] && blogPosts[index + 1].frontmatter.path
      }
    });
  });

  // Create Design Pages
  const designs = result?.data?.designs?.nodes;

  designs?.forEach(({ slug }, index) => {
    createPage({
      path: `/${slug}`,
      component: path.resolve(`src/templates/Design/DesignTemplate.tsx`),
      context: {
        slug: `/${slug}/`,
        prev: designs[index - 1] && designs[index - 1].slug,
        next: designs[index + 1] && designs[index + 1].slug
      }
    });
  });

  /*   // Create blog-list pages
  const entriesPerPage = 4;
  const numBlogPages = Math.ceil(blogPosts.length / entriesPerPage);
  Array.from({ length: numBlogPages })
    .slice(0, entriesPerPage)
    .forEach((_, i) => {
      createPage({
        path: `/page/${i + 1}`,
        component: path.resolve('./src/templates/BlogListTemplate.tsx'),
        context: {
          limit: entriesPerPage,
          skip: i * entriesPerPage,
          numBlogPages,
          currentPage: i + 1
        }
      });
    }); */
  /*
  // Create blog-list pages
  const numDesignPages = Math.ceil(designs.length / entriesPerPage);
  Array.from({ length: numDesignPages })
    .slice(0, entriesPerPage)
    .forEach((_, i) => {
      createPage({
        path: i === 0 ? `/designs` : `/designs/${i + 1}`,
        component: path.resolve('./src/templates/BlogListTemplate.tsx'),
        context: {
          limit: entriesPerPage,
          skip: i * entriesPerPage,
          numBlogPages,
          currentPage: i + 1
        }
      });
    }); */

  await createPostsPages(gatsbyNode);
  await createDesignListPages(gatsbyNode);
};

// Generated by https://quicktype.io

export interface Results {
  data: Data;
}

export interface Data {
  posts: Posts;
  designs: Designs;
  blogTags: Tags;
  designTags: Tags;
  sideProjectTags: Tags;
}

export interface Tags {
  group: Group[];
}

export interface Group {
  tag: string;
}

export interface Designs {
  nodes: DesignsNode[];
}

export interface DesignsNode {
  slug: string;
}

export interface Posts {
  nodes: PostsNode[];
}

export interface PostsNode {
  frontmatter: Frontmatter;
}

export interface Frontmatter {
  path: string;
}
